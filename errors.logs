{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-04-29T10:57:39.588Z'
}
{
  reason: 'replacement fee too low',
  code: 'REPLACEMENT_UNDERPRICED',
  error: ProviderError: replacement transaction underpriced
      at HttpProvider.request (/home/gheoneaemilian/houndrace-contracts/node_modules/hardhat/src/internal/core/providers/http.ts:74:19)
      at LocalAccountsProvider.request (/home/gheoneaemilian/houndrace-contracts/node_modules/hardhat/src/internal/core/providers/accounts.ts:182:36)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at EthersProviderWrapper.send (/home/gheoneaemilian/houndrace-contracts/node_modules/@nomiclabs/hardhat-ethers/src/internal/ethers-provider-wrapper.ts:13:20),
  method: 'sendTransaction',
  transaction: undefined,
  level: 'error',
  errorMessage: 'replacement fee too low [ See: https://links.ethers.org/v5-errors-REPLACEMENT_UNDERPRICED ] (error={"name":"ProviderError","code":-32000,"_isProviderError":true}, method="sendTransaction", transaction=undefined, code=REPLACEMENT_UNDERPRICED, version=providers/5.6.2)',
  timestamp: '2022-04-29T12:22:29.295Z'
}
{
  reason: 'invalid address or ENS name',
  code: 'INVALID_ARGUMENT',
  argument: 'name',
  value: 500000000,
  level: 'error',
  errorMessage: 'invalid address or ENS name (argument="name", value=500000000, code=INVALID_ARGUMENT, version=contracts/5.6.0)',
  timestamp: '2022-05-01T17:56:02.383Z'
}
{
  reason: 'invalid address or ENS name',
  code: 'INVALID_ARGUMENT',
  argument: 'name',
  value: 500000000,
  level: 'error',
  errorMessage: 'invalid address or ENS name (argument="name", value=500000000, code=INVALID_ARGUMENT, version=contracts/5.6.0)',
  timestamp: '2022-05-01T18:31:22.754Z'
}
{
  reason: 'invalid address or ENS name',
  code: 'INVALID_ARGUMENT',
  argument: 'name',
  value: 500000000,
  level: 'error',
  errorMessage: 'invalid address or ENS name (argument="name", value=500000000, code=INVALID_ARGUMENT, version=contracts/5.6.0)',
  timestamp: '2022-05-01T18:32:01.944Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-01T18:35:35.329Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-01T18:36:22.035Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-01T18:36:38.800Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The Etherscan API responded with a failure status.\n' +
    'The verification may still succeed but should be checked manually.\n' +
    'Reason: Already Verified',
  timestamp: '2022-05-01T18:48:50.167Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The Etherscan API responded with a failure status.\n' +
    'The verification may still succeed but should be checked manually.\n' +
    'Reason: Already Verified',
  timestamp: '2022-05-01T18:49:18.064Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The Etherscan API responded with a failure status.\n' +
    'The verification may still succeed but should be checked manually.\n' +
    'Reason: Already Verified',
  timestamp: '2022-05-01T18:51:01.225Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The Etherscan API responded with a failure status.\n' +
    'The verification may still succeed but should be checked manually.\n' +
    'Reason: Already Verified',
  timestamp: '2022-05-01T18:51:26.313Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The Etherscan API responded with a failure status.\n' +
    'The verification may still succeed but should be checked manually.\n' +
    'Reason: Already Verified',
  timestamp: '2022-05-01T18:52:00.833Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The Etherscan API responded with a failure status.\n' +
    'The verification may still succeed but should be checked manually.\n' +
    'Reason: Already Verified',
  timestamp: '2022-05-01T18:52:25.822Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The Etherscan API responded with a failure status.\n' +
    'The verification may still succeed but should be checked manually.\n' +
    'Reason: Already Verified',
  timestamp: '2022-05-01T18:52:50.810Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The Etherscan API responded with a failure status.\n' +
    'The verification may still succeed but should be checked manually.\n' +
    'Reason: Already Verified',
  timestamp: '2022-05-01T18:56:09.513Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The Etherscan API responded with a failure status.\n' +
    'The verification may still succeed but should be checked manually.\n' +
    'Reason: Already Verified',
  timestamp: '2022-05-01T18:56:34.296Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The Etherscan API responded with a failure status.\n' +
    'The verification may still succeed but should be checked manually.\n' +
    'Reason: Already Verified',
  timestamp: '2022-05-01T18:56:59.284Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The contract verification failed.\nReason: Fail - Unable to verify',
  timestamp: '2022-05-01T18:58:21.269Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The Etherscan API responded with a failure status.\n' +
    'The verification may still succeed but should be checked manually.\n' +
    'Reason: Already Verified',
  timestamp: '2022-05-01T18:58:46.959Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The Etherscan API responded with a failure status.\n' +
    'The verification may still succeed but should be checked manually.\n' +
    'Reason: Already Verified',
  timestamp: '2022-05-01T18:59:12.810Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The Etherscan API responded with a failure status.\n' +
    'The verification may still succeed but should be checked manually.\n' +
    'Reason: Already Verified',
  timestamp: '2022-05-01T19:00:20.086Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The Etherscan API responded with a failure status.\n' +
    'The verification may still succeed but should be checked manually.\n' +
    'Reason: Already Verified',
  timestamp: '2022-05-01T19:00:42.665Z'
}
{
  parent: Error: types/value length mismatch (argument="tuple", value=["0x168dfe79c84677Ce75EA8cB3183D8eaC0261FD2D","0x32f22770a824e628a26d63502b715881158F1A24","0x01184bEba46f5467cFdD90F2983acEc79354067d","0x038fa191c1cE8bcf6B4a19391e4473078A00f8eA","0x0000000000000000000000000000000000000000","0x25E6ffBC66BDA83BEE4C4D63715B0F6149413A95","0x9173c93E01B55ABD23C5E89b2f37979Cff9d5092",500000000,true], code=INVALID_ARGUMENT, version=abi/5.6.0)
      at Logger.makeError (/home/gheoneaemilian/houndrace-contracts/node_modules/@ethersproject/logger/src.ts/index.ts:261:28)
      at Logger.throwError (/home/gheoneaemilian/houndrace-contracts/node_modules/@ethersproject/logger/src.ts/index.ts:273:20)
      at Logger.throwArgumentError (/home/gheoneaemilian/houndrace-contracts/node_modules/@ethersproject/logger/src.ts/index.ts:277:21)
      at pack (/home/gheoneaemilian/houndrace-contracts/node_modules/@ethersproject/abi/src.ts/coders/array.ts:47:16)
      at TupleCoder.encode (/home/gheoneaemilian/houndrace-contracts/node_modules/@ethersproject/abi/src.ts/coders/tuple.ts:54:20)
      at /home/gheoneaemilian/houndrace-contracts/node_modules/@ethersproject/abi/src.ts/coders/array.ts:71:19
      at Array.forEach (<anonymous>)
      at pack (/home/gheoneaemilian/houndrace-contracts/node_modules/@ethersproject/abi/src.ts/coders/array.ts:54:12)
      at TupleCoder.encode (/home/gheoneaemilian/houndrace-contracts/node_modules/@ethersproject/abi/src.ts/coders/tuple.ts:54:20)
      at AbiCoder.encode (/home/gheoneaemilian/houndrace-contracts/node_modules/@ethersproject/abi/src.ts/abi-coder.ts:112:15) {
    reason: 'types/value length mismatch',
    code: 'INVALID_ARGUMENT',
    argument: 'tuple',
    value: [
      '0x168dfe79c84677Ce75EA8cB3183D8eaC0261FD2D',
      '0x32f22770a824e628a26d63502b715881158F1A24',
      '0x01184bEba46f5467cFdD90F2983acEc79354067d',
      '0x038fa191c1cE8bcf6B4a19391e4473078A00f8eA',
      '0x0000000000000000000000000000000000000000',
      '0x25E6ffBC66BDA83BEE4C4D63715B0F6149413A95',
      '0x9173c93E01B55ABD23C5E89b2f37979Cff9d5092',
      500000000,
      true
    ]
  },
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'Value 0x168dfe79c84677Ce75EA8cB3183D8eaC0261FD2D,0x32f22770a824e628a26d63502b715881158F1A24,0x01184bEba46f5467cFdD90F2983acEc79354067d,0x038fa191c1cE8bcf6B4a19391e4473078A00f8eA,0x0000000000000000000000000000000000000000,0x25E6ffBC66BDA83BEE4C4D63715B0F6149413A95,0x9173c93E01B55ABD23C5E89b2f37979Cff9d5092,500000000,true cannot be encoded for the parameter tuple.\n' +
    'Encoder error reason: types/value length mismatch',
  timestamp: '2022-05-01T19:02:32.578Z'
}
{
  reason: 'missing argument: passed to contract',
  code: 'MISSING_ARGUMENT',
  count: 1,
  expectedCount: 2,
  level: 'error',
  errorMessage: 'missing argument: passed to contract (count=1, expectedCount=2, code=MISSING_ARGUMENT, version=contracts/5.6.0)',
  timestamp: '2022-05-02T12:11:35.462Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function queue(uint256 theId) external view returns(Queue.Struct memory) {\n' +
          '        return queues[theId];\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHoundsZerocost(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '        \n' +
          '        IHoundsModifier(control.hounds).updateHoundStamina(hound);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '            \n' +
          '            IRacesMethods(control.races).raceStart(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 24,
        range: [ 737, 794 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundStamina',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function hound(uint256 theId) external view returns(Hound.Struct memory) {\n' +
          '        return hounds[theId];\n' +
          '    }\n' +
          '\n' +
          '    function tokenURI(uint256 _tokenId) public view override returns (string memory) {\n' +
          '        return hounds[_tokenId].token_uri;\n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 26,
        range: [ 865, 921 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundStamina',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '\n' +
          '        hounds[theId].running = true;\n' +
          '        \n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShopMethods(control.boilerplate.shopMethods).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        \n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        \n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '    \n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '\n' +
          '        uint256 discount = IShopMethods(control.boilerplate.shopMethods).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        \n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        \n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 11,
        range: [ 259, 287 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0x4697f3486036bb2734568491a360f60729e2da8047cb0f377a0f52181932041f',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-02T12:17:25.501Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function queue(uint256 theId) external view returns(Queue.Struct memory) {\n' +
          '        return queues[theId];\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHoundsZerocost(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '        \n' +
          '        IHoundsModifier(control.hounds).updateHoundStamina(hound);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '            \n' +
          '            IRacesMethods(control.races).raceStart(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 24,
        range: [ 737, 794 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundStamina',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function hound(uint256 theId) external view returns(Hound.Struct memory) {\n' +
          '        return hounds[theId];\n' +
          '    }\n' +
          '\n' +
          '    function tokenURI(uint256 _tokenId) public view override returns (string memory) {\n' +
          '        return hounds[_tokenId].token_uri;\n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 26,
        range: [ 865, 921 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundStamina',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '\n' +
          '        hounds[theId].running = true;\n' +
          '        \n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShopMethods(control.boilerplate.shopMethods).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        \n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        \n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '    \n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '\n' +
          '        uint256 discount = IShopMethods(control.boilerplate.shopMethods).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        \n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        \n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 11,
        range: [ 259, 287 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0x4697f3486036bb2734568491a360f60729e2da8047cb0f377a0f52181932041f',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-02T13:01:09.474Z'
}
{
  message: 'Check: ["Test queue","0x0000000000000000000000000000000000000000",{"type":"BigNumber","hex":"0x01"},{"type":"BigNumber","hex":"0x012a05f200"},{"type":"BigNumber","hex":"0x00"},{"type":"BigNumber","hex":"0x00"},{"type":"BigNumber","hex":"0x01"},10]',
  level: 'error',
  errorMessage: 'Check: ["Test queue","0x0000000000000000000000000000000000000000",{"type":"BigNumber","hex":"0x01"},{"type":"BigNumber","hex":"0x012a05f200"},{"type":"BigNumber","hex":"0x00"},{"type":"BigNumber","hex":"0x00"},{"type":"BigNumber","hex":"0x01"},10]',
  timestamp: '2022-05-02T13:02:07.263Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function queue(uint256 theId) external view returns(Queue.Struct memory) {\n' +
          '        return queues[theId];\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHoundsZerocost(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '        \n' +
          '        IHoundsModifier(control.hounds).updateHoundStamina(hound);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '            \n' +
          '            IRacesMethods(control.races).raceStart(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 24,
        range: [ 737, 794 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundStamina',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function hound(uint256 theId) external view returns(Hound.Struct memory) {\n' +
          '        return hounds[theId];\n' +
          '    }\n' +
          '\n' +
          '    function tokenURI(uint256 _tokenId) public view override returns (string memory) {\n' +
          '        return hounds[_tokenId].token_uri;\n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 26,
        range: [ 865, 921 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundStamina',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '\n' +
          '        hounds[theId].running = true;\n' +
          '        \n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShopMethods(control.boilerplate.shopMethods).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        \n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        \n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '    \n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '\n' +
          '        uint256 discount = IShopMethods(control.boilerplate.shopMethods).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        \n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        \n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 11,
        range: [ 259, 287 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0x4697f3486036bb2734568491a360f60729e2da8047cb0f377a0f52181932041f',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-02T13:02:07.443Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function queue(uint256 theId) external view returns(Queue.Struct memory) {\n' +
          '        return queues[theId];\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHoundsZerocost(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '        \n' +
          '        IHoundsModifier(control.hounds).updateHoundStamina(hound);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '            \n' +
          '            IRacesMethods(control.races).raceStart(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 24,
        range: [ 737, 794 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundStamina',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function hound(uint256 theId) external view returns(Hound.Struct memory) {\n' +
          '        return hounds[theId];\n' +
          '    }\n' +
          '\n' +
          '    function tokenURI(uint256 _tokenId) public view override returns (string memory) {\n' +
          '        return hounds[_tokenId].token_uri;\n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 26,
        range: [ 865, 921 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundStamina',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '\n' +
          '        hounds[theId].running = true;\n' +
          '        \n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShopMethods(control.boilerplate.shopMethods).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        \n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        \n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '    \n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '\n' +
          '        uint256 discount = IShopMethods(control.boilerplate.shopMethods).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        \n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        \n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 11,
        range: [ 259, 287 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0x4697f3486036bb2734568491a360f60729e2da8047cb0f377a0f52181932041f',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-02T13:06:57.306Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function queue(uint256 theId) external view returns(Queue.Struct memory) {\n' +
          '        return queues[theId];\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHoundsZerocost(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '        \n' +
          '        IHoundsModifier(control.hounds).updateHoundStamina(hound);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '            \n' +
          '            IRacesMethods(control.races).raceStart(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 24,
        range: [ 737, 794 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundStamina',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function hound(uint256 theId) external view returns(Hound.Struct memory) {\n' +
          '        return hounds[theId];\n' +
          '    }\n' +
          '\n' +
          '    function tokenURI(uint256 _tokenId) public view override returns (string memory) {\n' +
          '        return hounds[_tokenId].token_uri;\n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 26,
        range: [ 865, 921 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundStamina',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '\n' +
          '        hounds[theId].running = true;\n' +
          '        \n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShopMethods(control.boilerplate.shopMethods).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        \n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        \n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '    \n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '\n' +
          '        uint256 discount = IShopMethods(control.boilerplate.shopMethods).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        \n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        \n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 11,
        range: [ 259, 287 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0x4722181d2bf90d1cdcd518ff3d8be4aff65870d288d0610c80841b4810d4e199',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-02T13:23:24.588Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'breedHounds',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function hound(uint256 theId) external view returns(Hound.Struct memory) {\n' +
          '        return hounds[theId];\n' +
          '    }\n' +
          '\n' +
          '    function tokenURI(uint256 _tokenId) public view override returns (string memory) {\n' +
          '        return hounds[_tokenId].token_uri;\n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 21,
        range: [ 698, 747 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'breedHounds',
        contract: 'HoundsMinter',
        sourceName: 'contracts/hounds/minter/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsMinter is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        require(\n' +
          '            hounds[hound2].breeding.breedCooldown < block.timestamp && \n' +
          '            hounds[hound1].breeding.breedCooldown < block.timestamp && \n' +
          '            !hounds[hound1].running && \n' +
          '            !hounds[hound2].running && \n' +
          '            ownerOf(hound1) == msg.sender\n' +
          '        );\n' +
          '\n' +
          '        if ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ) {\n' +
          '            require(msg.value >= control.fees.breedCost + control.fees.breedFee);\n' +
          '        } else {\n' +
          '            require(\n' +
          '                hounds[hound2].breeding.availableToBreed && \n' +
          '                msg.value >= control.fees.breedCost + control.fees.breedFee + hounds[hound2].breeding.breedingFee\n' +
          '            );\n' +
          '            require(payable(ownerOf(hound2)).send(hounds[hound2].breeding.breedingFee));\n' +
          '        }\n' +
          '\n' +
          '        require(payable(control.boilerplate.staterApi).send(control.fees.breedFee));\n' +
          '        hounds[hound2].breeding.breedCooldown = block.timestamp + 172800;\n' +
          '        hounds[hound1].breeding.breedCooldown = block.timestamp + 172800;\n' +
          '        Hound.Struct memory offspring = IIncubatorMethods(control.boilerplate.incubator).breedHounds(\n' +
          '            hound1, \n' +
          '            hounds[hound1], \n' +
          '            hound2, \n' +
          '            hounds[hound2]\n' +
          '        );\n' +
          '        IHoundsModifier(control.boilerplate.houndModifier).updateHoundBreeding(hound1);\n' +
          '        IHoundsModifier(control.boilerplate.houndModifier).updateHoundBreeding(hound2);\n' +
          '        emit BreedHound(id,msg.sender,offspring);\n' +
          '        ++id;\n' +
          '    } \n' +
          '\n' +
          '}',
        line: 38,
        range: [ 1502, 1580 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundBreeding',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '\n' +
          '        hounds[theId].running = true;\n' +
          '        \n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShopMethods(control.boilerplate.shopMethods).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        \n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        \n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '    \n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '\n' +
          '        uint256 discount = IShopMethods(control.boilerplate.shopMethods).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        \n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        \n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 43,
        range: [ 1872, 1900 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0xe10efea493e8f4b32754f7110ed2b982881905d6d74759cddc12dc48b8e0aa8c',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-02T13:27:17.738Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function queue(uint256 theId) external view returns(Queue.Struct memory) {\n' +
          '        return queues[theId];\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHoundsZerocost(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '        \n' +
          '        IHoundsModifier(control.hounds).updateHoundStamina(hound);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '            \n' +
          '            IRacesMethods(control.races).raceStart(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 24,
        range: [ 737, 794 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundStamina',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function hound(uint256 theId) external view returns(Hound.Struct memory) {\n' +
          '        return hounds[theId];\n' +
          '    }\n' +
          '\n' +
          '    function tokenURI(uint256 _tokenId) public view override returns (string memory) {\n' +
          '        return hounds[_tokenId].token_uri;\n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 26,
        range: [ 865, 921 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundStamina',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '\n' +
          '        hounds[theId].running = true;\n' +
          '        \n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShopMethods(control.boilerplate.shopMethods).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        \n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        \n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '    \n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '\n' +
          '        uint256 discount = IShopMethods(control.boilerplate.shopMethods).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        \n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        \n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 11,
        range: [ 259, 287 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0xbf25502b4507f67ca6f0aaf7cfef085cea1a020587a597e0d646a2392d3de275',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-02T13:29:36.372Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function queue(uint256 theId) external view returns(Queue.Struct memory) {\n' +
          '        return queues[theId];\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHoundsZerocost(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '        \n' +
          '        IHoundsModifier(control.hounds).updateHoundStamina(hound);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '            \n' +
          '            IRacesMethods(control.races).raceStart(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 28,
        range: [ 908, 961 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 17,
        range: [ 498, 536 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            (bool success, bytes memory output) = control.generator.call{ value: queue.entryFee * queue.totalParticipants }(\n' +
          '                abi.encodeWithSignature(\n' +
          '                    "generate((uint256,uint256[],address,uint256,uint32))",\n' +
          '                    queue\n' +
          '                )\n' +
          '            );\n' +
          '            require(success);\n' +
          '            \n' +
          '            races[id] = abi.decode(output,(Race.Struct));\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 19,
        range: [ 624, 640 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0x338ee5e27289e589034c5f13f770e635d05f183eff8f5f563cdd95c438e2992a',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-02T13:37:49.224Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-02T15:47:58.741Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-02T15:48:16.096Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-02T15:48:53.622Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-02T15:49:33.336Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-02T15:50:06.745Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function queue(uint256 theId) external view returns(Queue.Struct memory) {\n' +
          '        return queues[theId];\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHoundsZerocost(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '        \n' +
          '        IHoundsModifier(control.hounds).updateHoundStamina(hound);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            IRacesMethods(control.races).raceStart(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 27,
        range: [ 895, 948 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 17,
        range: [ 498, 536 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            console.log("The sender is: ", msg.sender);\n' +
          '\n' +
          '            (bool success, bytes memory output) = control.generator.call{ value: queue.entryFee * queue.totalParticipants }(\n' +
          '                abi.encodeWithSignature(\n' +
          '                    "generate((uint256,uint256[],address,uint256,uint32))",\n' +
          '                    queue\n' +
          '                )\n' +
          '            );\n' +
          '            require(success);\n' +
          '            \n' +
          '            races[id] = abi.decode(output,(Race.Struct));\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 681, 697 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0x338ee5e27289e589034c5f13f770e635d05f183eff8f5f563cdd95c438e2992a',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-02T15:51:09.296Z'
}
{
  parent: undefined,
  name: 'HardhatError',
  errorDescriptor: {
    number: 700,
    message: 'Artifact for contract "%contractName%" not found. %suggestion%',
    title: 'Artifact not found',
    description: 'Tried to import a nonexistent artifact.\n' +
      '\n' +
      "Please double check that your contracts have been compiled and double check your artifact's name.",
    shouldBeReported: false
  },
  number: 700,
  messageArguments: { contractName: 'HoundsZerocost', suggestion: '' },
  _isHardhatError: true,
  level: 'error',
  errorMessage: 'HH700: Artifact for contract "HoundsZerocost" not found. ',
  timestamp: '2022-05-02T18:51:13.767Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-02T18:52:23.663Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-02T18:53:19.788Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function queue(uint256 theId) external view returns(Queue.Struct memory) {\n' +
          '        return queues[theId];\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '        \n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            IRacesMethods(control.races).raceStart(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 27,
        range: [ 879, 932 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 17,
        range: [ 498, 536 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            console.log("The sender is: ", msg.sender);\n' +
          '\n' +
          '            (bool success, bytes memory output) = control.generator.call{ value: queue.entryFee * queue.totalParticipants }(\n' +
          '                abi.encodeWithSignature(\n' +
          '                    "generate((uint256,uint256[],address,uint256,uint32))",\n' +
          '                    queue\n' +
          '                )\n' +
          '            );\n' +
          '            require(success);\n' +
          '            \n' +
          '            races[id] = abi.decode(output,(Race.Struct));\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 681, 697 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0x8783fada2451c45a6c61298a33ee4096d50e9f3636cfa214c60149d2963140b4',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-02T18:58:23.735Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-02T19:00:40.863Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-03T06:08:42.331Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-03T06:10:30.337Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-03T06:12:10.452Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-03T06:13:31.725Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-03T06:14:48.324Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        console.log("Delete queue here !");\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function queue(uint256 theId) external view returns(Queue.Struct memory) {\n' +
          '        return queues[theId];\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 22,
        range: [ 681, 719 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '        \n' +
          '        console.log("Update hound stamina");\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            console.log("Race start here");\n' +
          '            IRacesMethods(control.races).raceStart(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 30,
        range: [ 969, 1022 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        console.log("Race start here, 1");\n' +
          '        require(allowed[msg.sender]);\n' +
          '        console.log("Race start here, 2");\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 19,
        range: [ 584, 622 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            console.log("The sender is: ", msg.sender);\n' +
          '            console.log("Race start here, 3");\n' +
          '\n' +
          '            (bool success, bytes memory output) = control.generator.call{ value: queue.entryFee * queue.totalParticipants }(\n' +
          '                abi.encodeWithSignature(\n' +
          '                    "generate((uint256,uint256[],address,uint256,uint32))",\n' +
          '                    queue\n' +
          '                )\n' +
          '            );\n' +
          '            require(success);\n' +
          '            \n' +
          '            races[id] = abi.decode(output,(Race.Struct));\n' +
          '            console.log("Race start here, 4");\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        console.log("Race start here, 5");\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 22,
        range: [ 728, 744 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0x8783fada2451c45a6c61298a33ee4096d50e9f3636cfa214c60149d2963140b4',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-03T06:26:07.128Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        console.log("Delete queue here !");\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function queue(uint256 theId) external view returns(Queue.Struct memory) {\n' +
          '        return queues[theId];\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 22,
        range: [ 681, 719 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '        \n' +
          '        console.log("Update hound stamina");\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            console.log("Race start here");\n' +
          '            IRacesMethods(control.races).raceStart(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 30,
        range: [ 969, 1022 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        console.log("Race start here, 1");\n' +
          '        require(allowed[msg.sender]);\n' +
          '        console.log("Race start here, 2");\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 19,
        range: [ 584, 622 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            console.log("The sender is: ", msg.sender);\n' +
          '            console.log("Race start here, 3");\n' +
          '\n' +
          '            (bool success, bytes memory output) = control.generator.call{ value: queue.entryFee * queue.totalParticipants }(\n' +
          '                abi.encodeWithSignature(\n' +
          '                    "generate((uint256,uint256[],address,uint256,uint32))",\n' +
          '                    queue\n' +
          '                )\n' +
          '            );\n' +
          '            require(success);\n' +
          '            \n' +
          '            races[id] = abi.decode(output,(Race.Struct));\n' +
          '            console.log("Race start here, 4");\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        console.log("Race start here, 5");\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 22,
        range: [ 728, 744 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0x8783fada2451c45a6c61298a33ee4096d50e9f3636cfa214c60149d2963140b4',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-03T06:29:00.434Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        console.log("Delete queue here !");\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function queue(uint256 theId) external view returns(Queue.Struct memory) {\n' +
          '        return queues[theId];\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 22,
        range: [ 681, 719 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '        \n' +
          '        console.log("Update hound stamina");\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            console.log("Race start here");\n' +
          '            IRacesMethods(control.races).raceStart(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 30,
        range: [ 969, 1022 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        console.log("Race start here, 1");\n' +
          '        require(allowed[msg.sender]);\n' +
          '        console.log("Race start here, 2");\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 19,
        range: [ 584, 622 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            console.log("The sender is: ", msg.sender);\n' +
          '            console.log("Race start here, 3");\n' +
          '\n' +
          '            (bool success, bytes memory output) = control.generator.call{ value: queue.entryFee * queue.totalParticipants }(\n' +
          '                abi.encodeWithSignature(\n' +
          '                    "generate((uint256,uint256[],address,uint256,uint32))",\n' +
          '                    queue\n' +
          '                )\n' +
          '            );\n' +
          '            require(success);\n' +
          '            \n' +
          '            races[id] = abi.decode(output,(Race.Struct));\n' +
          '            console.log("Race start here, 4");\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        console.log("Race start here, 5");\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 22,
        range: [ 728, 744 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0x8783fada2451c45a6c61298a33ee4096d50e9f3636cfa214c60149d2963140b4',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-03T06:32:36.915Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        console.log("Delete queue here !");\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function queue(uint256 theId) external view returns(Queue.Struct memory) {\n' +
          '        return queues[theId];\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 22,
        range: [ 681, 719 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '        \n' +
          '        console.log("Update hound stamina");\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            console.log("Race start here");\n' +
          '            IRacesMethods(control.races).raceStart(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 30,
        range: [ 969, 1022 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        console.log("Race start here, 1");\n' +
          '        require(allowed[msg.sender]);\n' +
          '        console.log("Race start here, 2");\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 19,
        range: [ 584, 622 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            console.log("The sender is: ", msg.sender);\n' +
          '            console.log("Race start here, 3");\n' +
          '\n' +
          '            (bool success, bytes memory output) = control.generator.call{ value: queue.entryFee * queue.totalParticipants }(\n' +
          '                abi.encodeWithSignature(\n' +
          '                    "generate((string,address,uint256[],uint256,uint256,uint256,uint256,uint256,uint32))",\n' +
          '                    queue\n' +
          '                )\n' +
          '            );\n' +
          '            require(success);\n' +
          '            \n' +
          '            races[id] = abi.decode(output,(Race.Struct));\n' +
          '            console.log("Race start here, 4");\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        console.log("Race start here, 5");\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 22,
        range: [ 759, 775 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0x8783fada2451c45a6c61298a33ee4096d50e9f3636cfa214c60149d2963140b4',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-03T06:35:45.137Z'
}
