{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-03T14:30:45.827Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-03T14:37:38.284Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-03T14:39:06.423Z'
}
{
  reason: 'replacement fee too low',
  code: 'REPLACEMENT_UNDERPRICED',
  error: ProviderError: replacement transaction underpriced
      at HttpProvider.request (/home/gheoneaemilian/houndrace-contracts/node_modules/hardhat/src/internal/core/providers/http.ts:74:19)
      at LocalAccountsProvider.request (/home/gheoneaemilian/houndrace-contracts/node_modules/hardhat/src/internal/core/providers/accounts.ts:182:36)
      at runMicrotasks (<anonymous>)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at EthersProviderWrapper.send (/home/gheoneaemilian/houndrace-contracts/node_modules/@nomiclabs/hardhat-ethers/src/internal/ethers-provider-wrapper.ts:13:20),
  method: 'sendTransaction',
  transaction: undefined,
  level: 'error',
  errorMessage: 'replacement fee too low [ See: https://links.ethers.org/v5-errors-REPLACEMENT_UNDERPRICED ] (error={"name":"ProviderError","code":-32000,"_isProviderError":true}, method="sendTransaction", transaction=undefined, code=REPLACEMENT_UNDERPRICED, version=providers/5.6.5)',
  timestamp: '2022-05-04T05:55:16.135Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-04T07:21:36.813Z'
}
{
  level: 'error',
  errorMessage: 'paymentsMethods is not defined',
  timestamp: '2022-05-04T07:31:49.977Z'
}
{
  level: 'error',
  errorMessage: 'paymentsMethods is not defined',
  timestamp: '2022-05-04T07:31:49.977Z'
}
{
  level: 'error',
  errorMessage: 'shopMethods is not defined',
  timestamp: '2022-05-04T07:31:50.173Z'
}
{
  level: 'error',
  errorMessage: 'shopRestricted is not defined',
  timestamp: '2022-05-04T07:31:50.173Z'
}
{
  level: 'error',
  errorMessage: 'shopMethods is not defined',
  timestamp: '2022-05-04T07:31:50.174Z'
}
{
  level: 'error',
  errorMessage: 'arenasRestricted is not defined',
  timestamp: '2022-05-04T07:31:50.267Z'
}
{
  level: 'error',
  errorMessage: 'arenasRestricted is not defined',
  timestamp: '2022-05-04T07:31:50.267Z'
}
{
  level: 'error',
  errorMessage: 'randomness is not defined',
  timestamp: '2022-05-04T07:31:50.286Z'
}
{
  level: 'error',
  errorMessage: 'incubatorMethods is not defined',
  timestamp: '2022-05-04T07:31:50.358Z'
}
{
  level: 'error',
  errorMessage: 'incubatorMethods is not defined',
  timestamp: '2022-05-04T07:31:50.359Z'
}
{
  level: 'error',
  errorMessage: 'incubator is not defined',
  timestamp: '2022-05-04T07:31:50.736Z'
}
{
  level: 'error',
  errorMessage: 'randomness is not defined',
  timestamp: '2022-05-04T07:31:50.876Z'
}
{
  level: 'error',
  errorMessage: 'sortings is not defined',
  timestamp: '2022-05-04T07:31:50.928Z'
}
{
  level: 'error',
  errorMessage: 'randomness is not defined',
  timestamp: '2022-05-04T07:31:50.944Z'
}
{
  level: 'error',
  errorMessage: 'generatorMethods is not defined',
  timestamp: '2022-05-04T07:31:50.944Z'
}
{
  level: 'error',
  errorMessage: 'generatorZerocost is not defined',
  timestamp: '2022-05-04T07:31:50.944Z'
}
{
  level: 'error',
  errorMessage: 'arenas is not defined',
  timestamp: '2022-05-04T07:31:50.958Z'
}
{
  level: 'error',
  errorMessage: 'arenas is not defined',
  timestamp: '2022-05-04T07:31:50.973Z'
}
{
  level: 'error',
  errorMessage: 'arenas is not defined',
  timestamp: '2022-05-04T07:31:50.986Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-04T11:05:32.193Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-04T11:05:47.788Z'
}
{
  parent: undefined,
  name: 'ProviderError',
  code: -32000,
  _isProviderError: true,
  data: undefined,
  level: 'error',
  errorMessage: 'already known',
  timestamp: '2022-05-04T11:06:09.410Z'
}
{
  parent: undefined,
  name: 'ProviderError',
  code: -32000,
  _isProviderError: true,
  data: undefined,
  level: 'error',
  errorMessage: 'already known',
  timestamp: '2022-05-04T11:06:23.422Z'
}
{
  reason: 'insufficient funds for intrinsic transaction cost',
  code: 'INSUFFICIENT_FUNDS',
  error: ProviderError: insufficient funds for gas * price + value
      at HttpProvider.request (/home/gheoneaemilian/houndrace-contracts/node_modules/hardhat/src/internal/core/providers/http.ts:74:19)
      at LocalAccountsProvider.request (/home/gheoneaemilian/houndrace-contracts/node_modules/hardhat/src/internal/core/providers/accounts.ts:182:36)
      at runMicrotasks (<anonymous>)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at EthersProviderWrapper.send (/home/gheoneaemilian/houndrace-contracts/node_modules/@nomiclabs/hardhat-ethers/src/internal/ethers-provider-wrapper.ts:13:20),
  method: 'sendTransaction',
  transaction: undefined,
  level: 'error',
  errorMessage: 'insufficient funds for intrinsic transaction cost [ See: https://links.ethers.org/v5-errors-INSUFFICIENT_FUNDS ] (error={"name":"ProviderError","code":-32000,"_isProviderError":true}, method="sendTransaction", transaction=undefined, code=INSUFFICIENT_FUNDS, version=providers/5.6.5)',
  timestamp: '2022-05-04T11:06:37.728Z'
}
{
  reason: 'insufficient funds for intrinsic transaction cost',
  code: 'INSUFFICIENT_FUNDS',
  error: ProviderError: insufficient funds for gas * price + value
      at HttpProvider.request (/home/gheoneaemilian/houndrace-contracts/node_modules/hardhat/src/internal/core/providers/http.ts:74:19)
      at LocalAccountsProvider.request (/home/gheoneaemilian/houndrace-contracts/node_modules/hardhat/src/internal/core/providers/accounts.ts:182:36)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at EthersProviderWrapper.send (/home/gheoneaemilian/houndrace-contracts/node_modules/@nomiclabs/hardhat-ethers/src/internal/ethers-provider-wrapper.ts:13:20),
  method: 'sendTransaction',
  transaction: undefined,
  level: 'error',
  errorMessage: 'insufficient funds for intrinsic transaction cost [ See: https://links.ethers.org/v5-errors-INSUFFICIENT_FUNDS ] (error={"name":"ProviderError","code":-32000,"_isProviderError":true}, method="sendTransaction", transaction=undefined, code=INSUFFICIENT_FUNDS, version=providers/5.6.5)',
  timestamp: '2022-05-04T11:07:01.594Z'
}
{
  reason: 'replacement fee too low',
  code: 'REPLACEMENT_UNDERPRICED',
  error: ProviderError: replacement transaction underpriced
      at HttpProvider.request (/home/gheoneaemilian/houndrace-contracts/node_modules/hardhat/src/internal/core/providers/http.ts:74:19)
      at LocalAccountsProvider.request (/home/gheoneaemilian/houndrace-contracts/node_modules/hardhat/src/internal/core/providers/accounts.ts:182:36)
      at runMicrotasks (<anonymous>)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at EthersProviderWrapper.send (/home/gheoneaemilian/houndrace-contracts/node_modules/@nomiclabs/hardhat-ethers/src/internal/ethers-provider-wrapper.ts:13:20),
  method: 'sendTransaction',
  transaction: undefined,
  level: 'error',
  errorMessage: 'replacement fee too low [ See: https://links.ethers.org/v5-errors-REPLACEMENT_UNDERPRICED ] (error={"name":"ProviderError","code":-32000,"_isProviderError":true}, method="sendTransaction", transaction=undefined, code=REPLACEMENT_UNDERPRICED, version=providers/5.6.5)',
  timestamp: '2022-05-04T11:17:05.212Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-04T11:17:05.885Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-04T11:17:06.536Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-04T11:17:07.254Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-04T11:17:08.020Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-04T11:17:08.599Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-04T11:17:09.223Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-04T11:17:09.832Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-04T11:17:10.430Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-04T11:17:11.018Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-04T11:17:11.654Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-04T11:17:12.249Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-04T11:17:12.825Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-04T11:17:13.458Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-04T11:17:14.060Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-04T11:17:14.655Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-04T11:17:15.262Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-04T11:17:15.858Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-04T11:17:16.493Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-04T11:17:17.096Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-04T11:17:17.686Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-04T11:17:18.294Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-04T11:17:18.887Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-04T11:17:19.485Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-04T11:17:20.098Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-04T11:17:20.706Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-04T11:17:21.310Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '        IHounds(control.hounds).updateHoundRunning(theId, true);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            IRacesMethods(control.races).raceStart{ value: queues[theId].entryFee * queues[theId].totalParticipants }(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 28,
        range: [ 936, 1056 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race, Payment.Struct[] memory payments) external payable onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 17,
        range: [ 540, 578 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            Payment.Struct[] memory payments = IPayments(control.payments).getPayments(queue.rewardsId);\n' +
          '\n' +
          '            uint256 ethToSend = 0;\n' +
          '\n' +
          '            races[id] = IGenerator(control.generator).generate(queue);\n' +
          '\n' +
          '            // custom ERC20 / ERC721 / ERC1155 will be sent to the contract that makes the transfer, to avoid code complications\n' +
          '            for ( uint256 i = 0 ; i < payments.length ; ++i ) {\n' +
          '                if ( payments[i].currency == address(0) ) {\n' +
          '                    if ( payments[i].paymentType == 3 ) {\n' +
          '                        payments[i].qty = msg.value / 100 * payments[i].percentageWon;\n' +
          '                        payments[i].to = payable(IHounds(control.hounds).houndOwner(races[id].participants[payments[i].place]));\n' +
          '                        IHounds(control.hounds).updateHoundRunning(races[id].participants[payments[i].place], false);\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    } else {\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    }\n' +
          '                }\n' +
          '            }\n' +
          '\n' +
          '            require(queue.entryFee * queue.totalParticipants <= msg.value);\n' +
          '\n' +
          '            IPayments(control.payments).sendHardcodedPayments{ value: ethToSend }(payments);\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            require(payable(control.staterApi).send(msg.value));\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 25,
        range: [ 1076, 1168 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success); \n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 51,
        range: [ 1819, 1875 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].running = running;\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 22,
        range: [ 911, 939 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0xc25094e32cd9377ac539c35b8c45a819f6c41337d612cbc4e750f8a0785ebff5',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-04T14:42:29.991Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-04T14:42:30.145Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '        IHounds(control.hounds).updateHoundRunning(theId, true);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            IRacesMethods(control.races).raceStart{ value: queues[theId].entryFee * queues[theId].totalParticipants }(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 28,
        range: [ 936, 1056 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race, Payment.Struct[] memory payments) external payable onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 17,
        range: [ 540, 578 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            Payment.Struct[] memory payments = IPayments(control.payments).getPayments(queue.rewardsId);\n' +
          '\n' +
          '            uint256 ethToSend = 0;\n' +
          '\n' +
          '            races[id] = IGenerator(control.generator).generate(queue);\n' +
          '\n' +
          '            // custom ERC20 / ERC721 / ERC1155 will be sent to the contract that makes the transfer, to avoid code complications\n' +
          '            for ( uint256 i = 0 ; i < payments.length ; ++i ) {\n' +
          '                if ( payments[i].currency == address(0) ) {\n' +
          '                    if ( payments[i].paymentType == 3 ) {\n' +
          '                        payments[i].qty = msg.value / 100 * payments[i].percentageWon;\n' +
          '                        payments[i].to = payable(IHounds(control.hounds).houndOwner(races[id].participants[payments[i].place]));\n' +
          '                        IHounds(control.hounds).updateHoundRunning(races[id].participants[payments[i].place], false);\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    } else {\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    }\n' +
          '                }\n' +
          '            }\n' +
          '\n' +
          '            require(queue.entryFee * queue.totalParticipants <= msg.value);\n' +
          '\n' +
          '            IPayments(control.payments).sendHardcodedPayments{ value: ethToSend }(payments);\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            require(payable(control.staterApi).send(msg.value));\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 25,
        range: [ 1076, 1168 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success); \n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 51,
        range: [ 1819, 1875 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].running = running;\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 22,
        range: [ 911, 939 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0xc25094e32cd9377ac539c35b8c45a819f6c41337d612cbc4e750f8a0785ebff5',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-04T14:43:26.352Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-04T14:43:26.519Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '        IHounds(control.hounds).updateHoundRunning(theId, true);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            IRacesMethods(control.races).raceStart{ value: queues[theId].entryFee * queues[theId].totalParticipants }(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 28,
        range: [ 936, 1056 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race, Payment.Struct[] memory payments) external payable onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 17,
        range: [ 540, 578 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            Payment.Struct[] memory payments = IPayments(control.payments).getPayments(queue.rewardsId);\n' +
          '\n' +
          '            uint256 ethToSend = 0;\n' +
          '\n' +
          '            races[id] = IGenerator(control.generator).generate(queue);\n' +
          '\n' +
          '            // custom ERC20 / ERC721 / ERC1155 will be sent to the contract that makes the transfer, to avoid code complications\n' +
          '            for ( uint256 i = 0 ; i < payments.length ; ++i ) {\n' +
          '                if ( payments[i].currency == address(0) ) {\n' +
          '                    if ( payments[i].paymentType == 3 ) {\n' +
          '                        payments[i].qty = msg.value / 100 * payments[i].percentageWon;\n' +
          '                        payments[i].to = payable(IHounds(control.hounds).houndOwner(races[id].participants[payments[i].place]));\n' +
          '                        IHounds(control.hounds).updateHoundRunning(races[id].participants[payments[i].place], false);\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    } else {\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    }\n' +
          '                }\n' +
          '            }\n' +
          '\n' +
          '            require(queue.entryFee * queue.totalParticipants <= msg.value);\n' +
          '\n' +
          '            IPayments(control.payments).sendHardcodedPayments{ value: ethToSend }(payments);\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            require(payable(control.staterApi).send(msg.value));\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 25,
        range: [ 1076, 1168 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success); \n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 51,
        range: [ 1819, 1875 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].running = running;\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 22,
        range: [ 911, 939 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0xc25094e32cd9377ac539c35b8c45a819f6c41337d612cbc4e750f8a0785ebff5',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-04T14:48:31.059Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-04T14:48:31.236Z'
}
{
  reason: 'replacement fee too low',
  code: 'REPLACEMENT_UNDERPRICED',
  error: ProviderError: replacement transaction underpriced
      at HttpProvider.request (/home/gheoneaemilian/houndrace-contracts/node_modules/hardhat/src/internal/core/providers/http.ts:74:19)
      at LocalAccountsProvider.request (/home/gheoneaemilian/houndrace-contracts/node_modules/hardhat/src/internal/core/providers/accounts.ts:182:36)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at EthersProviderWrapper.send (/home/gheoneaemilian/houndrace-contracts/node_modules/@nomiclabs/hardhat-ethers/src/internal/ethers-provider-wrapper.ts:13:20),
  method: 'sendTransaction',
  transaction: undefined,
  level: 'error',
  errorMessage: 'replacement fee too low [ See: https://links.ethers.org/v5-errors-REPLACEMENT_UNDERPRICED ] (error={"name":"ProviderError","code":-32000,"_isProviderError":true}, method="sendTransaction", transaction=undefined, code=REPLACEMENT_UNDERPRICED, version=providers/5.6.5)',
  timestamp: '2022-05-04T18:23:12.682Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-04T18:24:15.965Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '        IHounds(control.hounds).updateHoundRunning(theId, true);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            IRacesMethods(control.races).raceStart{ value: queues[theId].entryFee * queues[theId].totalParticipants }(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 28,
        range: [ 936, 1056 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race, Payment.Struct[] memory payments) external payable onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 17,
        range: [ 540, 578 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            Payment.Struct[] memory payments = IPayments(control.payments).getPayments(queue.rewardsId);\n' +
          '\n' +
          '            uint256 ethToSend = 0;\n' +
          '\n' +
          '            races[id] = IGenerator(control.generator).generate(queue);\n' +
          '\n' +
          '            // custom ERC20 / ERC721 / ERC1155 will be sent to the contract that makes the transfer, to avoid code complications\n' +
          '            for ( uint256 i = 0 ; i < payments.length ; ++i ) {\n' +
          '                if ( payments[i].currency == address(0) ) {\n' +
          '                    if ( payments[i].paymentType == 3 ) {\n' +
          '                        payments[i].qty = msg.value / 100 * payments[i].percentageWon;\n' +
          '                        payments[i].to = payable(IHounds(control.hounds).houndOwner(races[id].participants[payments[i].place]));\n' +
          '                        IHounds(control.hounds).updateHoundRunning(races[id].participants[payments[i].place], false);\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    } else {\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    }\n' +
          '                }\n' +
          '            }\n' +
          '\n' +
          '            require(queue.entryFee * queue.totalParticipants <= msg.value);\n' +
          '\n' +
          '            IPayments(control.payments).sendHardcodedPayments{ value: ethToSend }(payments);\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            require(payable(control.staterApi).send(msg.value));\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 25,
        range: [ 1076, 1168 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success); \n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 51,
        range: [ 1819, 1875 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].running = running;\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 22,
        range: [ 911, 939 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0xc25094e32cd9377ac539c35b8c45a819f6c41337d612cbc4e750f8a0785ebff5',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-05T09:27:51.331Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-05T09:27:51.488Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-05T09:35:30.696Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-05T09:35:31.217Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-05T09:35:31.871Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-05T09:35:32.610Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-05T09:35:33.488Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-05T09:35:34.138Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-05T09:35:34.807Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-05T09:35:35.414Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-05T09:35:35.950Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-05T09:35:36.695Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-05T09:35:37.471Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-05T09:35:38.087Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-05T09:35:38.756Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-05T09:35:39.458Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-05T09:35:41.571Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-05T09:35:43.595Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-05T09:35:45.469Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-05T09:35:46.911Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-05T09:35:47.948Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-05T09:35:48.968Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-05T09:35:49.786Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-05T09:35:50.412Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-05T09:35:50.987Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-05T09:35:51.833Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-05T09:35:52.557Z'
}
{
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json',
  level: 'error',
  errorMessage: "ENOENT: no such file or directory, open '/home/gheoneaemilian/houndrace-contracts/artifacts/build-info/6cee8145959831e9f94ba548cef818b7.json'",
  timestamp: '2022-05-05T09:35:53.169Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '        IHounds(control.hounds).updateHoundRunning(theId, true);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            IRacesMethods(control.races).raceStart{ value: queues[theId].entryFee * queues[theId].totalParticipants }(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 28,
        range: [ 936, 1056 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race, Payment.Struct[] memory payments) external payable onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 17,
        range: [ 540, 578 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            Payment.Struct[] memory payments = IPayments(control.payments).getPayments(queue.rewardsId);\n' +
          '\n' +
          '            uint256 ethToSend = 0;\n' +
          '\n' +
          '            races[id] = IGenerator(control.generator).generate(queue);\n' +
          '\n' +
          '            // custom ERC20 / ERC721 / ERC1155 will be sent to the contract that makes the transfer, to avoid code complications\n' +
          '            for ( uint256 i = 0 ; i < payments.length ; ++i ) {\n' +
          '                if ( payments[i].currency == address(0) ) {\n' +
          '                    if ( payments[i].paymentType == 3 ) {\n' +
          '                        payments[i].qty = msg.value / 100 * payments[i].percentageWon;\n' +
          '                        payments[i].to = payable(IHounds(control.hounds).houndOwner(races[id].participants[payments[i].place]));\n' +
          '                        IHounds(control.hounds).updateHoundRunning(races[id].participants[payments[i].place], false);\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    } else {\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    }\n' +
          '                }\n' +
          '            }\n' +
          '\n' +
          '            require(queue.entryFee * queue.totalParticipants <= msg.value);\n' +
          '\n' +
          '            IPayments(control.payments).sendHardcodedPayments{ value: ethToSend }(payments);\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            require(payable(control.staterApi).send(msg.value));\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 25,
        range: [ 1076, 1168 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success); \n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 51,
        range: [ 1819, 1875 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].running = running;\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 22,
        range: [ 911, 939 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0xc25094e32cd9377ac539c35b8c45a819f6c41337d612cbc4e750f8a0785ebff5',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-05T15:29:28.425Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-05T15:29:28.572Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '        IHounds(control.hounds).updateHoundRunning(theId, true);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            IRacesMethods(control.races).raceStart{ value: queues[theId].entryFee * queues[theId].totalParticipants }(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 28,
        range: [ 936, 1056 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race, Payment.Struct[] memory payments) external payable onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 17,
        range: [ 540, 578 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            Payment.Struct[] memory payments = IPayments(control.payments).getPayments(queue.rewardsId);\n' +
          '\n' +
          '            uint256 ethToSend = 0;\n' +
          '\n' +
          '            races[id] = IGenerator(control.generator).generate(queue);\n' +
          '\n' +
          '            // custom ERC20 / ERC721 / ERC1155 will be sent to the contract that makes the transfer, to avoid code complications\n' +
          '            for ( uint256 i = 0 ; i < payments.length ; ++i ) {\n' +
          '                if ( payments[i].currency == address(0) ) {\n' +
          '                    if ( payments[i].paymentType == 3 ) {\n' +
          '                        payments[i].qty = msg.value / 100 * payments[i].percentageWon;\n' +
          '                        payments[i].to = payable(IHounds(control.hounds).houndOwner(races[id].participants[payments[i].place]));\n' +
          '                        IHounds(control.hounds).updateHoundRunning(races[id].participants[payments[i].place], false);\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    } else {\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    }\n' +
          '                }\n' +
          '            }\n' +
          '\n' +
          '            require(queue.entryFee * queue.totalParticipants <= msg.value);\n' +
          '\n' +
          '            IPayments(control.payments).sendHardcodedPayments{ value: ethToSend }(payments);\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            require(payable(control.staterApi).send(msg.value));\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 25,
        range: [ 1076, 1168 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success); \n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 51,
        range: [ 1819, 1875 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].running = running;\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 22,
        range: [ 911, 939 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0xc25094e32cd9377ac539c35b8c45a819f6c41337d612cbc4e750f8a0785ebff5',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-05T15:35:01.512Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-05T15:35:01.667Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '        IHounds(control.hounds).updateHoundRunning(theId, true);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            IRacesMethods(control.races).raceStart{ value: queues[theId].entryFee * queues[theId].totalParticipants }(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 28,
        range: [ 936, 1056 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race, Payment.Struct[] memory payments) external payable onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 17,
        range: [ 540, 578 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            Payment.Struct[] memory payments = IPayments(control.payments).getPayments(queue.rewardsId);\n' +
          '\n' +
          '            uint256 ethToSend = 0;\n' +
          '\n' +
          '            races[id] = IGenerator(control.generator).generate(queue);\n' +
          '\n' +
          '            // custom ERC20 / ERC721 / ERC1155 will be sent to the contract that makes the transfer, to avoid code complications\n' +
          '            for ( uint256 i = 0 ; i < payments.length ; ++i ) {\n' +
          '                if ( payments[i].currency == address(0) ) {\n' +
          '                    if ( payments[i].paymentType == 3 ) {\n' +
          '                        payments[i].qty = msg.value / 100 * payments[i].percentageWon;\n' +
          '                        payments[i].to = payable(IHounds(control.hounds).houndOwner(races[id].participants[payments[i].place]));\n' +
          '                        IHounds(control.hounds).updateHoundRunning(races[id].participants[payments[i].place], false);\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    } else {\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    }\n' +
          '                }\n' +
          '            }\n' +
          '\n' +
          '            require(queue.entryFee * queue.totalParticipants <= msg.value);\n' +
          '\n' +
          '            IPayments(control.payments).sendHardcodedPayments{ value: ethToSend }(payments);\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            require(payable(control.staterApi).send(msg.value));\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 25,
        range: [ 1076, 1168 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success); \n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 51,
        range: [ 1819, 1875 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].running = running;\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 22,
        range: [ 911, 939 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0xc25094e32cd9377ac539c35b8c45a819f6c41337d612cbc4e750f8a0785ebff5',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-05T15:35:40.472Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-05T15:35:40.621Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '        IHounds(control.hounds).updateHoundRunning(theId, true);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            IRacesMethods(control.races).raceStart{ value: queues[theId].entryFee * queues[theId].totalParticipants }(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 28,
        range: [ 936, 1056 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race, Payment.Struct[] memory payments) external payable onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 17,
        range: [ 540, 578 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            Payment.Struct[] memory payments = IPayments(control.payments).getPayments(queue.rewardsId);\n' +
          '\n' +
          '            uint256 ethToSend = 0;\n' +
          '\n' +
          '            races[id] = IGenerator(control.generator).generate(queue);\n' +
          '\n' +
          '            // custom ERC20 / ERC721 / ERC1155 will be sent to the contract that makes the transfer, to avoid code complications\n' +
          '            for ( uint256 i = 0 ; i < payments.length ; ++i ) {\n' +
          '                if ( payments[i].currency == address(0) ) {\n' +
          '                    if ( payments[i].paymentType == 3 ) {\n' +
          '                        payments[i].qty = msg.value / 100 * payments[i].percentageWon;\n' +
          '                        payments[i].to = payable(IHounds(control.hounds).houndOwner(races[id].participants[payments[i].place]));\n' +
          '                        IHounds(control.hounds).updateHoundRunning(races[id].participants[payments[i].place], false);\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    } else {\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    }\n' +
          '                }\n' +
          '            }\n' +
          '\n' +
          '            require(queue.entryFee * queue.totalParticipants <= msg.value);\n' +
          '\n' +
          '            IPayments(control.payments).sendHardcodedPayments{ value: ethToSend }(payments);\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            require(payable(control.staterApi).send(msg.value));\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 25,
        range: [ 1076, 1168 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success); \n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 51,
        range: [ 1819, 1875 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].running = running;\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 22,
        range: [ 911, 939 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0xc25094e32cd9377ac539c35b8c45a819f6c41337d612cbc4e750f8a0785ebff5',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-05T15:35:54.097Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-05T15:35:54.250Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '        IHounds(control.hounds).updateHoundRunning(theId, true);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            IRacesMethods(control.races).raceStart{ value: queues[theId].entryFee * queues[theId].totalParticipants }(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 28,
        range: [ 936, 1056 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race, Payment.Struct[] memory payments) external payable onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 17,
        range: [ 540, 578 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            Payment.Struct[] memory payments = IPayments(control.payments).getPayments(queue.rewardsId);\n' +
          '\n' +
          '            uint256 ethToSend = 0;\n' +
          '\n' +
          '            races[id] = IGenerator(control.generator).generate(queue);\n' +
          '\n' +
          '            // custom ERC20 / ERC721 / ERC1155 will be sent to the contract that makes the transfer, to avoid code complications\n' +
          '            for ( uint256 i = 0 ; i < payments.length ; ++i ) {\n' +
          '                if ( payments[i].currency == address(0) ) {\n' +
          '                    if ( payments[i].paymentType == 3 ) {\n' +
          '                        payments[i].qty = msg.value / 100 * payments[i].percentageWon;\n' +
          '                        payments[i].to = payable(IHounds(control.hounds).houndOwner(races[id].participants[payments[i].place]));\n' +
          '                        IHounds(control.hounds).updateHoundRunning(races[id].participants[payments[i].place], false);\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    } else {\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    }\n' +
          '                }\n' +
          '            }\n' +
          '\n' +
          '            require(queue.entryFee * queue.totalParticipants <= msg.value);\n' +
          '\n' +
          '            IPayments(control.payments).sendHardcodedPayments{ value: ethToSend }(payments);\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            require(payable(control.staterApi).send(msg.value));\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 25,
        range: [ 1076, 1168 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success); \n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 51,
        range: [ 1819, 1875 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].running = running;\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 22,
        range: [ 911, 939 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0xc25094e32cd9377ac539c35b8c45a819f6c41337d612cbc4e750f8a0785ebff5',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-05T15:36:15.615Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-05T15:36:15.760Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '        IHounds(control.hounds).updateHoundRunning(theId, true);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            IRacesMethods(control.races).raceStart{ value: queues[theId].entryFee * queues[theId].totalParticipants }(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 28,
        range: [ 936, 1056 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race, Payment.Struct[] memory payments) external payable onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 17,
        range: [ 540, 578 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            Payment.Struct[] memory payments = IPayments(control.payments).getPayments(queue.rewardsId);\n' +
          '\n' +
          '            uint256 ethToSend = 0;\n' +
          '\n' +
          '            races[id] = IGenerator(control.generator).generate(queue);\n' +
          '\n' +
          '            // custom ERC20 / ERC721 / ERC1155 will be sent to the contract that makes the transfer, to avoid code complications\n' +
          '            for ( uint256 i = 0 ; i < payments.length ; ++i ) {\n' +
          '                if ( payments[i].currency == address(0) ) {\n' +
          '                    if ( payments[i].paymentType == 3 ) {\n' +
          '                        payments[i].qty = msg.value / 100 * payments[i].percentageWon;\n' +
          '                        payments[i].to = payable(IHounds(control.hounds).houndOwner(races[id].participants[payments[i].place]));\n' +
          '                        IHounds(control.hounds).updateHoundRunning(races[id].participants[payments[i].place], false);\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    } else {\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    }\n' +
          '                }\n' +
          '            }\n' +
          '\n' +
          '            require(queue.entryFee * queue.totalParticipants <= msg.value);\n' +
          '\n' +
          '            IPayments(control.payments).sendHardcodedPayments{ value: ethToSend }(payments);\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            require(payable(control.staterApi).send(msg.value));\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 25,
        range: [ 1076, 1168 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success); \n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 51,
        range: [ 1819, 1875 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].running = running;\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 22,
        range: [ 911, 939 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0xc25094e32cd9377ac539c35b8c45a819f6c41337d612cbc4e750f8a0785ebff5',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-05T15:36:40.509Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-05T15:36:40.668Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '        IHounds(control.hounds).updateHoundRunning(theId, true);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            IRacesMethods(control.races).raceStart{ value: queues[theId].entryFee * queues[theId].totalParticipants }(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 28,
        range: [ 936, 1056 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race, Payment.Struct[] memory payments) external payable onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 17,
        range: [ 540, 578 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            Payment.Struct[] memory payments = IPayments(control.payments).getPayments(queue.rewardsId);\n' +
          '\n' +
          '            uint256 ethToSend = 0;\n' +
          '\n' +
          '            races[id] = IGenerator(control.generator).generate(queue);\n' +
          '\n' +
          '            // custom ERC20 / ERC721 / ERC1155 will be sent to the contract that makes the transfer, to avoid code complications\n' +
          '            for ( uint256 i = 0 ; i < payments.length ; ++i ) {\n' +
          '                if ( payments[i].currency == address(0) ) {\n' +
          '                    if ( payments[i].paymentType == 3 ) {\n' +
          '                        payments[i].qty = msg.value / 100 * payments[i].percentageWon;\n' +
          '                        payments[i].to = payable(IHounds(control.hounds).houndOwner(races[id].participants[payments[i].place]));\n' +
          '                        IHounds(control.hounds).updateHoundRunning(races[id].participants[payments[i].place], false);\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    } else {\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    }\n' +
          '                }\n' +
          '            }\n' +
          '\n' +
          '            require(queue.entryFee * queue.totalParticipants <= msg.value);\n' +
          '\n' +
          '            IPayments(control.payments).sendHardcodedPayments{ value: ethToSend }(payments);\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            require(payable(control.staterApi).send(msg.value));\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 25,
        range: [ 1076, 1168 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success); \n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 51,
        range: [ 1819, 1875 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].running = running;\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 22,
        range: [ 911, 939 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0xc25094e32cd9377ac539c35b8c45a819f6c41337d612cbc4e750f8a0785ebff5',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-05T15:37:14.071Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-05T15:37:14.218Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '        IHounds(control.hounds).updateHoundRunning(theId, true);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            IRacesMethods(control.races).raceStart{ value: queues[theId].entryFee * queues[theId].totalParticipants }(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 28,
        range: [ 936, 1056 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race, Payment.Struct[] memory payments) external payable onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 17,
        range: [ 540, 578 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            Payment.Struct[] memory payments = IPayments(control.payments).getPayments(queue.rewardsId);\n' +
          '\n' +
          '            uint256 ethToSend = 0;\n' +
          '\n' +
          '            races[id] = IGenerator(control.generator).generate(queue);\n' +
          '\n' +
          '            // custom ERC20 / ERC721 / ERC1155 will be sent to the contract that makes the transfer, to avoid code complications\n' +
          '            for ( uint256 i = 0 ; i < payments.length ; ++i ) {\n' +
          '                if ( payments[i].currency == address(0) ) {\n' +
          '                    if ( payments[i].paymentType == 3 ) {\n' +
          '                        payments[i].qty = msg.value / 100 * payments[i].percentageWon;\n' +
          '                        payments[i].to = payable(IHounds(control.hounds).houndOwner(races[id].participants[payments[i].place]));\n' +
          '                        IHounds(control.hounds).updateHoundRunning(races[id].participants[payments[i].place], false);\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    } else {\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    }\n' +
          '                }\n' +
          '            }\n' +
          '\n' +
          '            require(queue.entryFee * queue.totalParticipants <= msg.value);\n' +
          '\n' +
          '            IPayments(control.payments).sendHardcodedPayments{ value: ethToSend }(payments);\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            require(payable(control.staterApi).send(msg.value));\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 25,
        range: [ 1076, 1168 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success); \n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 51,
        range: [ 1819, 1875 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].running = running;\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 22,
        range: [ 911, 939 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0xc25094e32cd9377ac539c35b8c45a819f6c41337d612cbc4e750f8a0785ebff5',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-05T15:38:09.165Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-05T15:38:09.316Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '        IHounds(control.hounds).updateHoundRunning(theId, true);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            IRacesMethods(control.races).raceStart{ value: queues[theId].entryFee * queues[theId].totalParticipants }(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 28,
        range: [ 936, 1056 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race, Payment.Struct[] memory payments) external payable onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 17,
        range: [ 540, 578 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            Payment.Struct[] memory payments = IPayments(control.payments).getPayments(queue.rewardsId);\n' +
          '\n' +
          '            uint256 ethToSend = 0;\n' +
          '\n' +
          '            races[id] = IGenerator(control.generator).generate(queue);\n' +
          '\n' +
          '            // custom ERC20 / ERC721 / ERC1155 will be sent to the contract that makes the transfer, to avoid code complications\n' +
          '            for ( uint256 i = 0 ; i < payments.length ; ++i ) {\n' +
          '                if ( payments[i].currency == address(0) ) {\n' +
          '                    if ( payments[i].paymentType == 3 ) {\n' +
          '                        payments[i].qty = msg.value / 100 * payments[i].percentageWon;\n' +
          '                        payments[i].to = payable(IHounds(control.hounds).houndOwner(races[id].participants[payments[i].place]));\n' +
          '                        IHounds(control.hounds).updateHoundRunning(races[id].participants[payments[i].place], false);\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    } else {\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    }\n' +
          '                }\n' +
          '            }\n' +
          '\n' +
          '            require(queue.entryFee * queue.totalParticipants <= msg.value);\n' +
          '\n' +
          '            IPayments(control.payments).sendHardcodedPayments{ value: ethToSend }(payments);\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            require(payable(control.staterApi).send(msg.value));\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 25,
        range: [ 1076, 1168 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success); \n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 51,
        range: [ 1819, 1875 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].running = running;\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 22,
        range: [ 911, 939 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0xc25094e32cd9377ac539c35b8c45a819f6c41337d612cbc4e750f8a0785ebff5',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-05T15:42:44.027Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-05T15:42:44.171Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '        IHounds(control.hounds).updateHoundRunning(theId, true);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            IRacesMethods(control.races).raceStart{ value: queues[theId].entryFee * queues[theId].totalParticipants }(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 28,
        range: [ 936, 1056 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race, Payment.Struct[] memory payments) external payable onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 17,
        range: [ 540, 578 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            Payment.Struct[] memory payments = IPayments(control.payments).getPayments(queue.rewardsId);\n' +
          '\n' +
          '            uint256 ethToSend = 0;\n' +
          '\n' +
          '            races[id] = IGenerator(control.generator).generate(queue);\n' +
          '\n' +
          '            // custom ERC20 / ERC721 / ERC1155 will be sent to the contract that makes the transfer, to avoid code complications\n' +
          '            for ( uint256 i = 0 ; i < payments.length ; ++i ) {\n' +
          '                if ( payments[i].currency == address(0) ) {\n' +
          '                    if ( payments[i].paymentType == 3 ) {\n' +
          '                        payments[i].qty = msg.value / 100 * payments[i].percentageWon;\n' +
          '                        payments[i].to = payable(IHounds(control.hounds).houndOwner(races[id].participants[payments[i].place]));\n' +
          '                        IHounds(control.hounds).updateHoundRunning(races[id].participants[payments[i].place], false);\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    } else {\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    }\n' +
          '                }\n' +
          '            }\n' +
          '\n' +
          '            require(queue.entryFee * queue.totalParticipants <= msg.value);\n' +
          '\n' +
          '            IPayments(control.payments).sendHardcodedPayments{ value: ethToSend }(payments);\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            require(payable(control.staterApi).send(msg.value));\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 25,
        range: [ 1076, 1168 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success); \n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 51,
        range: [ 1819, 1875 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].running = running;\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 22,
        range: [ 911, 939 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0xc25094e32cd9377ac539c35b8c45a819f6c41337d612cbc4e750f8a0785ebff5',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-05T15:43:09.422Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-05T15:43:09.575Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The address 0xDA140B402F8F2B02983f2A79d248DDdB418c3d60 has no bytecode. Is the contract deployed to this network?\n' +
    'The selected network is rinkeby.',
  timestamp: '2022-05-06T09:04:15.201Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The address 0x6f80bf5cAf752936F99737E97EF591Da9786C906 has no bytecode. Is the contract deployed to this network?\n' +
    'The selected network is rinkeby.',
  timestamp: '2022-05-06T09:07:07.645Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The address 0xA5F28b46D9466550C51d93d28d35e2DD06DD361a has no bytecode. Is the contract deployed to this network?\n' +
    'The selected network is rinkeby.',
  timestamp: '2022-05-06T09:11:40.644Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The address 0xEaC4ef5f4e932f75B4Dc02B1Cd7d6Ee75d4f2158 has no bytecode. Is the contract deployed to this network?\n' +
    'The selected network is rinkeby.',
  timestamp: '2022-05-06T09:15:12.918Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The address 0xbB598D313D28F450f2E4fea3977132c323459099 has no bytecode. Is the contract deployed to this network?\n' +
    'The selected network is rinkeby.',
  timestamp: '2022-05-06T09:16:54.704Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The address 0x1fdb0f2B4aFb1648020eAa0b0FE79Eacb4c2eeA7 has no bytecode. Is the contract deployed to this network?\n' +
    'The selected network is rinkeby.',
  timestamp: '2022-05-06T10:24:02.905Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The address 0x8818C48a7f3c3E212c39269f17d8520950b575a8 has no bytecode. Is the contract deployed to this network?\n' +
    'The selected network is rinkeby.',
  timestamp: '2022-05-06T10:34:52.736Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The address 0x63A7b08746E3fBE65e5291daFa6AbD9Eb5D25a57 has no bytecode. Is the contract deployed to this network?\n' +
    'The selected network is rinkeby.',
  timestamp: '2022-05-06T10:44:41.737Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The address 0xdeB6375Fd6e7a17C621AD45046aFFf4DA7f6c4A2 has no bytecode. Is the contract deployed to this network?\n' +
    'The selected network is rinkeby.',
  timestamp: '2022-05-06T10:51:19.663Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The address 0x46c514E7Ae9A5062025a16E0a3b595e3A76Aa716 has no bytecode. Is the contract deployed to this network?\n' +
    'The selected network is rinkeby.',
  timestamp: '2022-05-06T10:54:04.374Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-06T11:25:35.146Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-06T11:31:43.203Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-06T11:32:24.917Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-06T11:32:59.649Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-06T11:47:23.233Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-06T11:47:55.240Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '        IHounds(control.hounds).updateHoundRunning(theId, true);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            IRacesMethods(control.races).raceStart{ value: queues[theId].entryFee * queues[theId].totalParticipants }(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 28,
        range: [ 936, 1056 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race, Payment.Struct[] memory payments) external payable onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 17,
        range: [ 540, 578 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            Payment.Struct[] memory payments = IPayments(control.payments).getPayments(queue.rewardsId);\n' +
          '\n' +
          '            uint256 ethToSend = 0;\n' +
          '\n' +
          '            races[id] = IGenerator(control.generator).generate(queue);\n' +
          '\n' +
          '            // custom ERC20 / ERC721 / ERC1155 will be sent to the contract that makes the transfer, to avoid code complications\n' +
          '            for ( uint256 i = 0 ; i < payments.length ; ++i ) {\n' +
          '                if ( payments[i].currency == address(0) ) {\n' +
          '                    if ( payments[i].paymentType == 3 ) {\n' +
          '                        payments[i].qty = msg.value / 100 * payments[i].percentageWon;\n' +
          '                        payments[i].to = payable(IHounds(control.hounds).houndOwner(races[id].participants[payments[i].place]));\n' +
          '                        IHounds(control.hounds).updateHoundRunning(races[id].participants[payments[i].place], false);\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    } else {\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    }\n' +
          '                }\n' +
          '            }\n' +
          '\n' +
          '            require(queue.entryFee * queue.totalParticipants <= msg.value);\n' +
          '\n' +
          '            IPayments(control.payments).sendHardcodedPayments{ value: ethToSend }(payments);\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            require(payable(control.staterApi).send(msg.value));\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 25,
        range: [ 1076, 1168 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success); \n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 51,
        range: [ 1819, 1875 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].running = running;\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 22,
        range: [ 911, 939 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0xc25094e32cd9377ac539c35b8c45a819f6c41337d612cbc4e750f8a0785ebff5',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-06T12:05:09.607Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-06T12:05:09.769Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '        IHounds(control.hounds).updateHoundRunning(theId, true);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            IRacesMethods(control.races).raceStart{ value: queues[theId].entryFee * queues[theId].totalParticipants }(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 28,
        range: [ 936, 1056 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race, Payment.Struct[] memory payments) external payable onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 17,
        range: [ 540, 578 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            Payment.Struct[] memory payments = IPayments(control.payments).getPayments(queue.rewardsId);\n' +
          '\n' +
          '            uint256 ethToSend = 0;\n' +
          '\n' +
          '            races[id] = IGenerator(control.generator).generate(queue);\n' +
          '\n' +
          '            // custom ERC20 / ERC721 / ERC1155 will be sent to the contract that makes the transfer, to avoid code complications\n' +
          '            for ( uint256 i = 0 ; i < payments.length ; ++i ) {\n' +
          '                if ( payments[i].currency == address(0) ) {\n' +
          '                    if ( payments[i].paymentType == 3 ) {\n' +
          '                        payments[i].qty = msg.value / 100 * payments[i].percentageWon;\n' +
          '                        payments[i].to = payable(IHounds(control.hounds).houndOwner(races[id].participants[payments[i].place]));\n' +
          '                        IHounds(control.hounds).updateHoundRunning(races[id].participants[payments[i].place], false);\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    } else {\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    }\n' +
          '                }\n' +
          '            }\n' +
          '\n' +
          '            require(queue.entryFee * queue.totalParticipants <= msg.value);\n' +
          '\n' +
          '            IPayments(control.payments).sendHardcodedPayments{ value: ethToSend }(payments);\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            require(payable(control.staterApi).send(msg.value));\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 25,
        range: [ 1076, 1168 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success); \n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 51,
        range: [ 1819, 1875 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].running = running;\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 22,
        range: [ 911, 939 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0xc25094e32cd9377ac539c35b8c45a819f6c41337d612cbc4e750f8a0785ebff5',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-06T12:25:22.413Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-06T12:25:22.538Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '        IHounds(control.hounds).updateHoundRunning(theId, true);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            IRacesMethods(control.races).raceStart{ value: queues[theId].entryFee * queues[theId].totalParticipants }(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 28,
        range: [ 936, 1056 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race, Payment.Struct[] memory payments) external payable onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 17,
        range: [ 540, 578 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            Payment.Struct[] memory payments = IPayments(control.payments).getPayments(queue.rewardsId);\n' +
          '\n' +
          '            uint256 ethToSend = 0;\n' +
          '\n' +
          '            races[id] = IGenerator(control.generator).generate(queue);\n' +
          '\n' +
          '            // custom ERC20 / ERC721 / ERC1155 will be sent to the contract that makes the transfer, to avoid code complications\n' +
          '            for ( uint256 i = 0 ; i < payments.length ; ++i ) {\n' +
          '                if ( payments[i].currency == address(0) ) {\n' +
          '                    if ( payments[i].paymentType == 3 ) {\n' +
          '                        payments[i].qty = msg.value / 100 * payments[i].percentageWon;\n' +
          '                        payments[i].to = payable(IHounds(control.hounds).houndOwner(races[id].participants[payments[i].place]));\n' +
          '                        IHounds(control.hounds).updateHoundRunning(races[id].participants[payments[i].place], false);\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    } else {\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    }\n' +
          '                }\n' +
          '            }\n' +
          '\n' +
          '            require(queue.entryFee * queue.totalParticipants <= msg.value);\n' +
          '\n' +
          '            IPayments(control.payments).sendHardcodedPayments{ value: ethToSend }(payments);\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            require(payable(control.staterApi).send(msg.value));\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 25,
        range: [ 1076, 1168 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success); \n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 51,
        range: [ 1819, 1875 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].running = running;\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 22,
        range: [ 911, 939 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0xc25094e32cd9377ac539c35b8c45a819f6c41337d612cbc4e750f8a0785ebff5',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-06T12:26:11.139Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-06T12:26:11.269Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '        IHounds(control.hounds).updateHoundRunning(theId, true);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            IRacesMethods(control.races).raceStart{ value: queues[theId].entryFee * queues[theId].totalParticipants }(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 28,
        range: [ 936, 1056 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race, Payment.Struct[] memory payments) external payable onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 17,
        range: [ 540, 578 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            Payment.Struct[] memory payments = IPayments(control.payments).getPayments(queue.rewardsId);\n' +
          '\n' +
          '            uint256 ethToSend = 0;\n' +
          '\n' +
          '            races[id] = IGenerator(control.generator).generate(queue);\n' +
          '\n' +
          '            // custom ERC20 / ERC721 / ERC1155 will be sent to the contract that makes the transfer, to avoid code complications\n' +
          '            for ( uint256 i = 0 ; i < payments.length ; ++i ) {\n' +
          '                if ( payments[i].currency == address(0) ) {\n' +
          '                    if ( payments[i].paymentType == 3 ) {\n' +
          '                        payments[i].qty = msg.value / 100 * payments[i].percentageWon;\n' +
          '                        payments[i].to = payable(IHounds(control.hounds).houndOwner(races[id].participants[payments[i].place]));\n' +
          '                        IHounds(control.hounds).updateHoundRunning(races[id].participants[payments[i].place], false);\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    } else {\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    }\n' +
          '                }\n' +
          '            }\n' +
          '\n' +
          '            require(queue.entryFee * queue.totalParticipants <= msg.value);\n' +
          '\n' +
          '            IPayments(control.payments).sendHardcodedPayments{ value: ethToSend }(payments);\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            require(payable(control.staterApi).send(msg.value));\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 25,
        range: [ 1076, 1168 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success); \n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 51,
        range: [ 1819, 1875 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].running = running;\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 22,
        range: [ 911, 939 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0xc25094e32cd9377ac539c35b8c45a819f6c41337d612cbc4e750f8a0785ebff5',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-06T12:26:35.836Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-06T12:26:35.968Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '        IHounds(control.hounds).updateHoundRunning(theId, true);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            IRacesMethods(control.races).raceStart{ value: queues[theId].entryFee * queues[theId].totalParticipants }(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 28,
        range: [ 936, 1056 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race, Payment.Struct[] memory payments) external payable onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 17,
        range: [ 540, 578 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            Payment.Struct[] memory payments = IPayments(control.payments).getPayments(queue.rewardsId);\n' +
          '\n' +
          '            uint256 ethToSend = 0;\n' +
          '\n' +
          '            races[id] = IGenerator(control.generator).generate(queue);\n' +
          '\n' +
          '            // custom ERC20 / ERC721 / ERC1155 will be sent to the contract that makes the transfer, to avoid code complications\n' +
          '            for ( uint256 i = 0 ; i < payments.length ; ++i ) {\n' +
          '                if ( payments[i].currency == address(0) ) {\n' +
          '                    if ( payments[i].paymentType == 3 ) {\n' +
          '                        payments[i].qty = msg.value / 100 * payments[i].percentageWon;\n' +
          '                        payments[i].to = payable(IHounds(control.hounds).houndOwner(races[id].participants[payments[i].place]));\n' +
          '                        IHounds(control.hounds).updateHoundRunning(races[id].participants[payments[i].place], false);\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    } else {\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    }\n' +
          '                }\n' +
          '            }\n' +
          '\n' +
          '            require(queue.entryFee * queue.totalParticipants <= msg.value);\n' +
          '\n' +
          '            IPayments(control.payments).sendHardcodedPayments{ value: ethToSend }(payments);\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            require(payable(control.staterApi).send(msg.value));\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 25,
        range: [ 1076, 1168 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success); \n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 51,
        range: [ 1819, 1875 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].running = running;\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 22,
        range: [ 911, 939 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0xc25094e32cd9377ac539c35b8c45a819f6c41337d612cbc4e750f8a0785ebff5',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-06T12:27:39.181Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-06T12:27:39.331Z'
}
{
  level: 'error',
  errorMessage: 'handleProgress is not defined',
  timestamp: '2022-05-06T12:34:40.597Z'
}
{
  level: 'error',
  errorMessage: 'handleProgress is not defined',
  timestamp: '2022-05-06T12:40:23.075Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '        IHounds(control.hounds).updateHoundRunning(theId, true);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            IRacesMethods(control.races).raceStart{ value: queues[theId].entryFee * queues[theId].totalParticipants }(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 28,
        range: [ 936, 1056 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race, Payment.Struct[] memory payments) external payable onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 17,
        range: [ 540, 578 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            Payment.Struct[] memory payments = IPayments(control.payments).getPayments(queue.rewardsId);\n' +
          '\n' +
          '            uint256 ethToSend = 0;\n' +
          '\n' +
          '            races[id] = IGenerator(control.generator).generate(queue);\n' +
          '\n' +
          '            // custom ERC20 / ERC721 / ERC1155 will be sent to the contract that makes the transfer, to avoid code complications\n' +
          '            for ( uint256 i = 0 ; i < payments.length ; ++i ) {\n' +
          '                if ( payments[i].currency == address(0) ) {\n' +
          '                    if ( payments[i].paymentType == 3 ) {\n' +
          '                        payments[i].qty = msg.value / 100 * payments[i].percentageWon;\n' +
          '                        payments[i].to = payable(IHounds(control.hounds).houndOwner(races[id].participants[payments[i].place]));\n' +
          '                        IHounds(control.hounds).updateHoundRunning(races[id].participants[payments[i].place], false);\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    } else {\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    }\n' +
          '                }\n' +
          '            }\n' +
          '\n' +
          '            require(queue.entryFee * queue.totalParticipants <= msg.value);\n' +
          '\n' +
          '            IPayments(control.payments).sendHardcodedPayments{ value: ethToSend }(payments);\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            require(payable(control.staterApi).send(msg.value));\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 25,
        range: [ 1076, 1168 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success); \n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 51,
        range: [ 1819, 1875 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].running = running;\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 22,
        range: [ 911, 939 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0xc25094e32cd9377ac539c35b8c45a819f6c41337d612cbc4e750f8a0785ebff5',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-06T12:58:04.821Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-06T12:58:04.962Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '        IHounds(control.hounds).updateHoundRunning(theId, true);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            IRacesMethods(control.races).raceStart{ value: queues[theId].entryFee * queues[theId].totalParticipants }(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 28,
        range: [ 936, 1056 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race, Payment.Struct[] memory payments) external payable onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 17,
        range: [ 540, 578 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            Payment.Struct[] memory payments = IPayments(control.payments).getPayments(queue.rewardsId);\n' +
          '\n' +
          '            uint256 ethToSend = 0;\n' +
          '\n' +
          '            races[id] = IGenerator(control.generator).generate(queue);\n' +
          '\n' +
          '            // custom ERC20 / ERC721 / ERC1155 will be sent to the contract that makes the transfer, to avoid code complications\n' +
          '            for ( uint256 i = 0 ; i < payments.length ; ++i ) {\n' +
          '                if ( payments[i].currency == address(0) ) {\n' +
          '                    if ( payments[i].paymentType == 3 ) {\n' +
          '                        payments[i].qty = msg.value / 100 * payments[i].percentageWon;\n' +
          '                        payments[i].to = payable(IHounds(control.hounds).houndOwner(races[id].participants[payments[i].place]));\n' +
          '                        IHounds(control.hounds).updateHoundRunning(races[id].participants[payments[i].place], false);\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    } else {\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    }\n' +
          '                }\n' +
          '            }\n' +
          '\n' +
          '            require(queue.entryFee * queue.totalParticipants <= msg.value);\n' +
          '\n' +
          '            IPayments(control.payments).sendHardcodedPayments{ value: ethToSend }(payments);\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            require(payable(control.staterApi).send(msg.value));\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 25,
        range: [ 1076, 1168 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success); \n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 51,
        range: [ 1819, 1875 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].running = running;\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 22,
        range: [ 911, 939 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0xc25094e32cd9377ac539c35b8c45a819f6c41337d612cbc4e750f8a0785ebff5',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-06T13:06:23.231Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-06T13:06:23.382Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '        IHounds(control.hounds).updateHoundRunning(theId, true);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            IRacesMethods(control.races).raceStart{ value: queues[theId].entryFee * queues[theId].totalParticipants }(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 28,
        range: [ 936, 1056 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race, Payment.Struct[] memory payments) external payable onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 17,
        range: [ 540, 578 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            Payment.Struct[] memory payments = IPayments(control.payments).getPayments(queue.rewardsId);\n' +
          '\n' +
          '            uint256 ethToSend = 0;\n' +
          '\n' +
          '            races[id] = IGenerator(control.generator).generate(queue);\n' +
          '\n' +
          '            // custom ERC20 / ERC721 / ERC1155 will be sent to the contract that makes the transfer, to avoid code complications\n' +
          '            for ( uint256 i = 0 ; i < payments.length ; ++i ) {\n' +
          '                if ( payments[i].currency == address(0) ) {\n' +
          '                    if ( payments[i].paymentType == 3 ) {\n' +
          '                        payments[i].qty = msg.value / 100 * payments[i].percentageWon;\n' +
          '                        payments[i].to = payable(IHounds(control.hounds).houndOwner(races[id].participants[payments[i].place]));\n' +
          '                        IHounds(control.hounds).updateHoundRunning(races[id].participants[payments[i].place], false);\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    } else {\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    }\n' +
          '                }\n' +
          '            }\n' +
          '\n' +
          '            require(queue.entryFee * queue.totalParticipants <= msg.value);\n' +
          '\n' +
          '            IPayments(control.payments).sendHardcodedPayments{ value: ethToSend }(payments);\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            require(payable(control.staterApi).send(msg.value));\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 25,
        range: [ 1076, 1168 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success); \n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 51,
        range: [ 1819, 1875 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].running = running;\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 22,
        range: [ 911, 939 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0xc25094e32cd9377ac539c35b8c45a819f6c41337d612cbc4e750f8a0785ebff5',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-06T13:07:43.422Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-06T13:07:43.551Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '        IHounds(control.hounds).updateHoundRunning(theId, true);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            IRacesMethods(control.races).raceStart{ value: queues[theId].entryFee * queues[theId].totalParticipants }(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 28,
        range: [ 936, 1056 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race, Payment.Struct[] memory payments) external payable onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 17,
        range: [ 540, 578 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            Payment.Struct[] memory payments = IPayments(control.payments).getPayments(queue.rewardsId);\n' +
          '\n' +
          '            uint256 ethToSend = 0;\n' +
          '\n' +
          '            races[id] = IGenerator(control.generator).generate(queue);\n' +
          '\n' +
          '            // custom ERC20 / ERC721 / ERC1155 will be sent to the contract that makes the transfer, to avoid code complications\n' +
          '            for ( uint256 i = 0 ; i < payments.length ; ++i ) {\n' +
          '                if ( payments[i].currency == address(0) ) {\n' +
          '                    if ( payments[i].paymentType == 3 ) {\n' +
          '                        payments[i].qty = msg.value / 100 * payments[i].percentageWon;\n' +
          '                        payments[i].to = payable(IHounds(control.hounds).houndOwner(races[id].participants[payments[i].place]));\n' +
          '                        IHounds(control.hounds).updateHoundRunning(races[id].participants[payments[i].place], false);\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    } else {\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    }\n' +
          '                }\n' +
          '            }\n' +
          '\n' +
          '            require(queue.entryFee * queue.totalParticipants <= msg.value);\n' +
          '\n' +
          '            IPayments(control.payments).sendHardcodedPayments{ value: ethToSend }(payments);\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            require(payable(control.staterApi).send(msg.value));\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 25,
        range: [ 1076, 1168 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success); \n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 51,
        range: [ 1819, 1875 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].running = running;\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 22,
        range: [ 911, 939 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0xc25094e32cd9377ac539c35b8c45a819f6c41337d612cbc4e750f8a0785ebff5',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-06T13:30:46.666Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-06T13:30:46.814Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '        IHounds(control.hounds).updateHoundRunning(theId, true);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            IRacesMethods(control.races).raceStart{ value: queues[theId].entryFee * queues[theId].totalParticipants }(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 28,
        range: [ 936, 1056 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race, Payment.Struct[] memory payments) external payable onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 17,
        range: [ 540, 578 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            Payment.Struct[] memory payments = IPayments(control.payments).getPayments(queue.rewardsId);\n' +
          '\n' +
          '            uint256 ethToSend = 0;\n' +
          '\n' +
          '            races[id] = IGenerator(control.generator).generate(queue);\n' +
          '\n' +
          '            // custom ERC20 / ERC721 / ERC1155 will be sent to the contract that makes the transfer, to avoid code complications\n' +
          '            for ( uint256 i = 0 ; i < payments.length ; ++i ) {\n' +
          '                if ( payments[i].currency == address(0) ) {\n' +
          '                    if ( payments[i].paymentType == 3 ) {\n' +
          '                        payments[i].qty = msg.value / 100 * payments[i].percentageWon;\n' +
          '                        payments[i].to = payable(IHounds(control.hounds).houndOwner(races[id].participants[payments[i].place]));\n' +
          '                        IHounds(control.hounds).updateHoundRunning(races[id].participants[payments[i].place], false);\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    } else {\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    }\n' +
          '                }\n' +
          '            }\n' +
          '\n' +
          '            require(queue.entryFee * queue.totalParticipants <= msg.value);\n' +
          '\n' +
          '            IPayments(control.payments).sendHardcodedPayments{ value: ethToSend }(payments);\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            require(payable(control.staterApi).send(msg.value));\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 25,
        range: [ 1076, 1168 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success); \n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 51,
        range: [ 1819, 1875 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].running = running;\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 22,
        range: [ 911, 939 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0xc25094e32cd9377ac539c35b8c45a819f6c41337d612cbc4e750f8a0785ebff5',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-06T13:40:36.509Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-06T13:40:36.633Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '        IHounds(control.hounds).updateHoundRunning(theId, true);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            IRacesMethods(control.races).raceStart{ value: queues[theId].entryFee * queues[theId].totalParticipants }(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 28,
        range: [ 936, 1056 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race, Payment.Struct[] memory payments) external payable onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 17,
        range: [ 540, 578 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            Payment.Struct[] memory payments = IPayments(control.payments).getPayments(queue.rewardsId);\n' +
          '\n' +
          '            uint256 ethToSend = 0;\n' +
          '\n' +
          '            races[id] = IGenerator(control.generator).generate(queue);\n' +
          '\n' +
          '            // custom ERC20 / ERC721 / ERC1155 will be sent to the contract that makes the transfer, to avoid code complications\n' +
          '            for ( uint256 i = 0 ; i < payments.length ; ++i ) {\n' +
          '                if ( payments[i].currency == address(0) ) {\n' +
          '                    if ( payments[i].paymentType == 3 ) {\n' +
          '                        payments[i].qty = msg.value / 100 * payments[i].percentageWon;\n' +
          '                        payments[i].to = payable(IHounds(control.hounds).houndOwner(races[id].participants[payments[i].place]));\n' +
          '                        IHounds(control.hounds).updateHoundRunning(races[id].participants[payments[i].place], false);\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    } else {\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    }\n' +
          '                }\n' +
          '            }\n' +
          '\n' +
          '            require(queue.entryFee * queue.totalParticipants <= msg.value);\n' +
          '\n' +
          '            IPayments(control.payments).sendHardcodedPayments{ value: ethToSend }(payments);\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            require(payable(control.staterApi).send(msg.value));\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 25,
        range: [ 1076, 1168 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success); \n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 51,
        range: [ 1819, 1875 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].running = running;\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 22,
        range: [ 911, 939 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0xc25094e32cd9377ac539c35b8c45a819f6c41337d612cbc4e750f8a0785ebff5',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-06T13:40:46.279Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-06T13:40:46.406Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '        IHounds(control.hounds).updateHoundRunning(theId, true);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            IRacesMethods(control.races).raceStart{ value: queues[theId].entryFee * queues[theId].totalParticipants }(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 28,
        range: [ 936, 1056 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race, Payment.Struct[] memory payments) external payable onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 17,
        range: [ 540, 578 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            Payment.Struct[] memory payments = IPayments(control.payments).getPayments(queue.rewardsId);\n' +
          '\n' +
          '            uint256 ethToSend = 0;\n' +
          '\n' +
          '            races[id] = IGenerator(control.generator).generate(queue);\n' +
          '\n' +
          '            // custom ERC20 / ERC721 / ERC1155 will be sent to the contract that makes the transfer, to avoid code complications\n' +
          '            for ( uint256 i = 0 ; i < payments.length ; ++i ) {\n' +
          '                if ( payments[i].currency == address(0) ) {\n' +
          '                    if ( payments[i].paymentType == 3 ) {\n' +
          '                        payments[i].qty = msg.value / 100 * payments[i].percentageWon;\n' +
          '                        payments[i].to = payable(IHounds(control.hounds).houndOwner(races[id].participants[payments[i].place]));\n' +
          '                        IHounds(control.hounds).updateHoundRunning(races[id].participants[payments[i].place], false);\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    } else {\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    }\n' +
          '                }\n' +
          '            }\n' +
          '\n' +
          '            require(queue.entryFee * queue.totalParticipants <= msg.value);\n' +
          '\n' +
          '            IPayments(control.payments).sendHardcodedPayments{ value: ethToSend }(payments);\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            require(payable(control.staterApi).send(msg.value));\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 25,
        range: [ 1076, 1168 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success); \n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 51,
        range: [ 1819, 1875 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].running = running;\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 22,
        range: [ 911, 939 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0xc25094e32cd9377ac539c35b8c45a819f6c41337d612cbc4e750f8a0785ebff5',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-06T13:52:25.960Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-06T13:52:26.078Z'
}
{
  stackTrace: [
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'Queues',
        sourceName: 'contracts/queues/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Queues is Params {\n' +
          '    \n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function createQueues(Queue.Struct[] memory theQueues) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function deleteQueue(uint256 theId) external onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 21,
        range: [ 637, 675 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'enqueue',
        contract: 'QueuesMethods',
        sourceName: 'contracts/queues/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract QueuesMethods is Params {\n' +
          '\n' +
          '    constructor(QueuesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function enqueue(uint256 theId, uint256 hound) external payable {\n' +
          '        require(queues[theId].totalParticipants > 0);\n' +
          '\n' +
          '        require((queues[theId].endDate == 0 && queues[theId].startDate ==0) || (queues[theId].startDate <= block.timestamp && queues[theId].endDate >= block.timestamp));\n' +
          '\n' +
          '        require(msg.value >= queues[theId].entryFee);\n' +
          '\n' +
          '        Hound.Struct memory houndObj = IHounds(control.hounds).hound(hound);\n' +
          '\n' +
          '        require(!houndObj.running);\n' +
          '\n' +
          '        queues[theId].participants.push(hound);\n' +
          '\n' +
          '        IHounds(control.hounds).updateHoundStamina(hound);\n' +
          '        IHounds(control.hounds).updateHoundRunning(theId, true);\n' +
          '\n' +
          '        if ( queues[theId].participants.length == queues[theId].totalParticipants ) {\n' +
          '\n' +
          '            IRacesMethods(control.races).raceStart{ value: queues[theId].entryFee * queues[theId].totalParticipants }(queues[theId]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        emit PlayerEnqueue(theId,hound,msg.sender);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 28,
        range: [ 936, 1056 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'Races',
        sourceName: 'contracts/races/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Races is Params {\n' +
          '    \n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function uploadRace(Race.Struct memory race, Payment.Struct[] memory payments) external payable onlyOwner {\n' +
          '        (bool success, ) = control.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        (bool success, ) = control.methods.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 17,
        range: [ 540, 578 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'raceStart',
        contract: 'RacesMethods',
        sourceName: 'contracts/races/methods/Index.sol',
        sourceContent: '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract RacesMethods is Params {\n' +
          '\n' +
          '    constructor(RacesConstructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function raceStart(Queue.Struct memory queue) external payable {\n' +
          '        if ( control.callable ) {\n' +
          '            \n' +
          '            Payment.Struct[] memory payments = IPayments(control.payments).getPayments(queue.rewardsId);\n' +
          '\n' +
          '            uint256 ethToSend = 0;\n' +
          '\n' +
          '            races[id] = IGenerator(control.generator).generate(queue);\n' +
          '\n' +
          '            // custom ERC20 / ERC721 / ERC1155 will be sent to the contract that makes the transfer, to avoid code complications\n' +
          '            for ( uint256 i = 0 ; i < payments.length ; ++i ) {\n' +
          '                if ( payments[i].currency == address(0) ) {\n' +
          '                    if ( payments[i].paymentType == 3 ) {\n' +
          '                        payments[i].qty = msg.value / 100 * payments[i].percentageWon;\n' +
          '                        payments[i].to = payable(IHounds(control.hounds).houndOwner(races[id].participants[payments[i].place]));\n' +
          '                        IHounds(control.hounds).updateHoundRunning(races[id].participants[payments[i].place], false);\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    } else {\n' +
          '                        ethToSend += payments[i].qty;\n' +
          '                    }\n' +
          '                }\n' +
          '            }\n' +
          '\n' +
          '            require(queue.entryFee * queue.totalParticipants <= msg.value);\n' +
          '\n' +
          '            IPayments(control.payments).sendHardcodedPayments{ value: ethToSend }(payments);\n' +
          '\n' +
          '            emit NewFinishedRace(id,  races[id]);\n' +
          '\n' +
          '        } else {\n' +
          '\n' +
          '            require(payable(control.staterApi).send(msg.value));\n' +
          '            emit NewRace(id, races[id]);\n' +
          '\n' +
          '        }\n' +
          '\n' +
          '        ++id;\n' +
          '\n' +
          '    }\n' +
          '\n' +
          '}\n',
        line: 25,
        range: [ 1076, 1168 ]
      },
      functionType: 1
    },
    {
      type: 0,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'Hounds',
        sourceName: 'contracts/hounds/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import './params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract Hounds is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '\n' +
          '    function initializeHound(uint256 onId, Hound.Struct memory theHound) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function setTokenURI(uint256 _tokenId, string memory token_uri) external onlyOwner {\n' +
          '        (bool success, ) = control.boilerplate.restricted.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function breedHounds(uint256 hound1, uint256 hound2) external payable {\n' +
          '        (bool success, ) = control.boilerplate.minter.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        (bool success, ) = control.boilerplate.houndModifier.delegatecall(msg.data);\n' +
          '        require(success); \n' +
          '    }\n' +
          '\n' +
          '    function getBreedCost(uint256 hound1, uint256 hound2) external view returns(uint256) {\n' +
          '        require(ownerOf(hound1) == msg.sender);\n' +
          '        return control.fees.breedCost + control.fees.breedFee + ( ownerOf(hound1) == msg.sender && ownerOf(hound2) == msg.sender ? 0 : hounds[hound2].breeding.breedingFee );\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 51,
        range: [ 1819, 1875 ]
      },
      functionType: 1
    },
    {
      type: 4,
      sourceReference: {
        function: 'updateHoundRunning',
        contract: 'HoundsModifier',
        sourceName: 'contracts/hounds/modifier/Index.sol',
        sourceContent: '//SPDX-License-Identifier: MIT\n' +
          'pragma solidity 0.8.13;\n' +
          "import '../params/Index.sol';\n" +
          '\n' +
          '\n' +
          'contract HoundsModifier is Params {\n' +
          '\n' +
          '    constructor(Constructor.Struct memory input) Params(input) {}\n' +
          '    \n' +
          '    function updateHoundStamina(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        --hounds[theId].stamina.staminaValue;\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundRunning(uint256 theId, bool running) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].running = running;\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundStamina(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillStaminaCooldownCost = control.fees.refillStaminaCooldownCost - ((control.fees.refillStaminaCooldownCost / 100) * discount);\n' +
          '        hounds[theId].stamina.staminaValue += uint32(msg.value / refillStaminaCooldownCost);\n' +
          '        hounds[theId].stamina.staminaValue += uint32( ( ( block.timestamp - hounds[theId].stamina.staminaLastUpdate ) / 3600 ) * hounds[theId].stamina.staminaPerHour );\n' +
          '        hounds[theId].stamina.staminaLastUpdate = block.timestamp;\n' +
          '        if ( hounds[theId].stamina.staminaValue > hounds[theId].stamina.staminaCap ) {\n' +
          '            hounds[theId].stamina.staminaValue = hounds[theId].stamina.staminaCap;\n' +
          '        }\n' +
          '        emit HoundStaminaUpdate(theId,hounds[theId].stamina.staminaValue);\n' +
          '    }\n' +
          '\n' +
          '    function updateHoundBreeding(uint256 theId) public {\n' +
          '        require(allowed[msg.sender]);\n' +
          '        hounds[theId].breeding.breedCooldown += 172800;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function boostHoundBreeding(uint256 theId, address user) public payable {\n' +
          '        uint256 discount = IShop(control.boilerplate.shop).calculateDiscount(user);\n' +
          '        uint256 refillBreedingCooldownCost = control.fees.refillBreedingCooldownCost - ((control.fees.refillBreedingCooldownCost / 100) * discount);\n' +
          '        hounds[theId].breeding.breedCooldown -= msg.value / refillBreedingCooldownCost;\n' +
          '        hounds[theId].breeding.breedLastUpdate = block.timestamp;\n' +
          '        emit HoundBreedingStatusUpdate(theId,hounds[theId].breeding.availableToBreed);\n' +
          '    }\n' +
          '\n' +
          '    function putHoundForBreed(uint256 theId, uint256 fee, bool status) external {\n' +
          '        require(ownerOf(theId) == msg.sender);\n' +
          '        if ( status )\n' +
          '            require(hounds[theId].breeding.breedCooldown < block.timestamp);\n' +
          '        hounds[theId].breeding.breedingFee = fee;\n' +
          '        hounds[theId].breeding.availableToBreed = status;\n' +
          '        emit HoundBreedable(theId,fee);\n' +
          '    }\n' +
          '\n' +
          '}',
        line: 22,
        range: [ 911, 939 ]
      },
      message: ReturnData { value: <Buffer > },
      isInvalidOpcodeError: false
    }
  ],
  transactionHash: '0xc25094e32cd9377ac539c35b8c45a819f6c41337d612cbc4e750f8a0785ebff5',
  level: 'error',
  errorMessage: 'Transaction reverted without a reason string',
  timestamp: '2022-05-06T14:27:52.572Z'
}
{
  parent: undefined,
  name: 'NomicLabsHardhatPluginError',
  pluginName: '@nomiclabs/hardhat-etherscan',
  _isHardhatPluginError: true,
  shouldBeReported: false,
  _isNomicLabsHardhatPluginError: true,
  level: 'error',
  errorMessage: 'The selected network is hardhat. Please select a network supported by Etherscan.',
  timestamp: '2022-05-06T14:27:52.702Z'
}
